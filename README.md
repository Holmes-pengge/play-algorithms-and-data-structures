## 算法与数据结构体系课程 - 课程官方代码仓

大家好， 欢迎大家来到我在[慕课网](http://www.imooc.com/)上的体系课程[《算法与数据结构》](https://class.imooc.com/sale/datastructure)的官方代码仓。这个代码仓将不仅仅包含课程的所有源代码，还将发布课程的更新相关内容，勘误信息以及计划的更多可以丰富课程的内容，如更多分享，多多练习，等等等等。课程全部使用Java语言讲解，课程代码仓暂时只提供Java语言版本。

大家可以下载、运行、测试、修改。如果你发现了任何bug，或者对课程中的任何内容有意见或建议，欢迎和我联系：）

**个人公众号：是不是很酷**：）

![QRCode](qrcode.png)

## 课程源码目录 

| **第一章 欢迎大家来到算法与数据结构的世界** | [无代码] |
| :---- | :----: |
| 1-1 欢迎大家来到算法与数据结构的世界 | [无代码] |
| 1-2 学习算法和数据结构到底有没有用？ | [无代码] |
| 1-3 更多课程学习注意事项 | [无代码] |
| 1-4 课程编程环境的搭建 | [无代码] |
| 1-5 【文字】JDK 的国内下载链接，和更多学习方法 | [无代码] |
| **第二章 线性查找法** | [章节Java源码](02-Linear-Search/) |
| 2-1 什么是算法 | [无代码] |
| 2-2 最简单的算法：线性查找法 | [无代码] |
| 2-3 实现线性查找法 | [Java](02-Linear-Search/03-Linaer-Search/src/) |
| 2-4 使用泛型 | [Java](02-Linear-Search/04-Using-Generic/src/) |
| 2-5 使用自定义类测试我们的算法 | [Java](02-Linear-Search/05-Using-Custom-Class/src/) |
| 2-6 循环不变量 | [无代码] |
| 2-7 简单的复杂度分析 | [无代码] |
| 2-8 常见的时间复杂度 | [无代码] |
| 2-9 测试算法性能 | [Java](02-Linear-Search/09-Test-Performance/src/) |
| 2-10 本章小结 | [无代码] |
| **第三章 选择排序法** | [章节Java源码](03-Selection-Sort/) |
| 3-1 最简单的排序算法：选择排序法 | [无代码] |
| 3-2 实现选择排序法 | [Java](03-Selection-Sort/02-Selection-Sort/src/) |
| 3-3 使用带约束的泛型 | [Java](03-Selection-Sort/03-Using-Generics/src/) |
| 3-4 使用 Comparable 接口 | [Java](03-Selection-Sort/04-Using-Comparable/src/) |
| 3-5 选择排序法的复杂度分析 | [Java](03-Selection-Sort/05-Performance-of-Selection-Sort/src/) |
| 3-6 作业：换个角度实现选择排序法 | [无代码] |
| 3-7 [文字] 作业解析：换个角度实现选择排序法 | [Java](03-Selection-Sort/07-Another-Selection-Sort/src/) |
| **第四章 插入排序法** | [章节Java源码](04-Insertion-Sort/) |
| 4-1 插入排序法 | [无代码] |
| 4-2 实现插入排序法 | [Java](04-Insertion-Sort/02-Insertion-Sort/src/) |
| 4-3 插入排序法的一个小优化 | [Java](04-Insertion-Sort/03-Insertion-Sort-Optimized/src/) |
| 4-4 插入排序法的特性 | [Java](04-Insertion-Sort/04-Insertion-Sort-Features/src/) |
| 4-5 作业：换个角度实现插入排序法 | [无代码] |
| 4-6 [文字] 作业解析：换个角度实现插入排序法 | [Java](04-Insertion-Sort/06-Another-Insertion-Sort/src/) |
| 4-7 本章小结 | [无代码] |
| **第五章 最基础的数据结构：不要小瞧数组** | [章节Java源码](05-Arrays/) |
| 5-1 为什么要研究数据结构 | [无代码] |
| 5-2 使用Java中的数组 | [Java](05-Arrays/02-Array-Basics/src/) |
| 5-3 二次封装属于我们自己的数组 | [Java](05-Arrays/03-Create-Our-Own-Array/src/) |
| 5-4 向数组中添加元素 | [Java](05-Arrays/04-Add-Element-in-Array/src/) |
| 5-5 数组中查询元素和修改元素 | [Java](05-Arrays/05-Query-and-Update-Element/src/) |
| 5-6 包含，搜索和删除 | [Java](05-Arrays/06-Contain-Find-and-Remove/src/) |
| 5-7 使用泛型 | [Java](05-Arrays/07-Generic-Data-Structures/src/) |
| 5-8 动态数组 | [Java](05-Arrays/08-Dynamic-Array/src/) |
| 5-9 简单的复杂度分析 | [无代码] |
| 5-10 均摊复杂度和防止复杂度的震荡 | [Java](05-Arrays/10-Amortized-Time-Complexity/src/) |
| **第六章 栈和队列** | [章节Java源码](06-Stacks-and-Queues/) |
| 6-1 栈和栈的应用：撤销操作和系统栈 | [无代码] |
| 6-2 栈的基本实现 | [Java](06-Stacks-and-Queues/02-Array-Stack/src/) |
| 6-3 栈的另一个应用：括号匹配 | [Java](06-Stacks-and-Queues/03-A-Stack-Problem-in-Leetcode/src/) |
| 6-4 关于Leetcode的更多说明 | [Java](06-Stacks-and-Queues/04-More-about-Leetcode/src/) |
| 6-5 数组队列 | [Java](06-Stacks-and-Queues/05-Array-Queue/src/) |
| 6-6 循环队列 | [Java](06-Stacks-and-Queues/06-Loop-Queue/src/) |
| 6-7 循环队列的实现 | [Java](06-Stacks-and-Queues/07-Implementation-of-Loop-Queue/src/) |
| 6-8 数组队列和循环队列的比较 | [Java](06-Stacks-and-Queues/08-Queues-Comparison/src/) |
| 6-9 作业：换个方式实现队列？ | [无代码] |
| 6-10 [文字] 作业解析：不浪费一个空间的循环队列 | [Java](06-Stacks-and-Queues/10-Loop-Queue-without-Wasting-One-Space/src/) |
| 6-11 [文字] 作业解析：没有size成员变量的循环队列 | [Java](06-Stacks-and-Queues/11-Loop-Queue-without-Size-Member/src/) |
| 6-12 作业：双端队列 | [无代码] |
| 6-13 [文字] 作业解析：实现双端队列 | [Java](06-Stacks-and-Queues/13-Deque/src/) |
| 6-14 [文字] 扩展阅读：Java 程序员，别用 Stack？！ | [无代码] |
| **第六章补充：栈和队列其他习题** | [章节Java源码](06x-Stacks-and-Queues/) |
| 6x-1 作业：用栈实现队列和用队列实现栈 | [无代码] |
| 6x-2 [文字] 作业解析：用队列实现栈 | [Java](06x-Stacks-and-Queues/02-LC225-Implement-Stack-using-Queues/src/) |
| 6x-3 [文字] 作业解析：用栈实现队列 | [Java](06x-Stacks-and-Queues/03-LC232-Implement-Queue-using-Stacks/src/) |
| 6x-4 [文字] 更多栈和队列的问题推荐 | [无代码] |
| | |
| **第七章 最基础的动态数据结构：链表** | [章节Java源码](07-Linked-List/) |
| 7-1 什么是链表 | [Java](07-Linked-List/01-Linked-List-Basics/src/) |
| 7-2 在链表中添加元素 | [Java](07-Linked-List/02-Add-Elements-in-LinkedList/src/) |
| 7-3 使用链表的虚拟头结点 | [Java](07-Linked-List/03-DummyHead-in-LinkedList/src/) |
| 7-4 链表的遍历，查询和修改 | [Java](07-Linked-List/04-Query-and-Update-in-LinkedList/src/) |
| 7-5 从链表中删除元素 | [Java](07-Linked-List/05-Remove-Element-in-LinkedList/src/) |
| 7-6 使用链表实现栈 | [Java](07-Linked-List/06-Implement-Stack-in-LinkedList/src/) |
| 7-7 带有尾指针的链表：使用链表实现队列 | [Java](07-Linked-List/07-Implement-Queue-in-LinkedList/src/) |
| 7-8 [文字] 链表的性能问题 | [Java](07-Linked-List/08-LinkedList-Performance/src/) |
| **第八章 透过链表看递归** | [章节Java源码](08-Recursion/) |
| 8-1 Leetcode中和链表相关的问题 | [Java](08-Recursion/01-Linked-List-Problems-in-Leetcode/src/) |
| 8-2 测试自己的Leetcode链表代码 | [Java](08-Recursion/02-Test-Your-LinkedList-Solution/src/) |
| 8-3 递归基础与递归的宏观语意 | [Java](08-Recursion/03-Recursion-Basics/src/) |
| 8-4 链表与递归 | [Java](08-Recursion/04-LinkedList-and-Recursion/src/) |
| 8-5 递归运行的机制：递归的微观解读 | [无代码] |
| 8-6 递归算法的调试 | [Java](08-Recursion/06-Debug-Recursive-Solution/src/) |
| 8-7 作业：链表的递归实现 | [无代码] |
| 8-8 [文字] 作业解析：链表的递归实现 | [Java](08-Recursion/08-Recursive-LinkedList/src/) |
| 8-9 链表添加元素递归方法的常见问题解析 | [无代码] |
| 8-10 更多和链表相关的话题 | [无代码] |
| 8-11 [文字] 斯坦福大学推荐的 18 个链表相关问题 | [无代码] |
| **第八章补充 链表相关习题** | [章节Java源码](08x-Linked-List/) |
| 8x-1 链表最经典的问题：翻转链表 | [无代码] |
| 8x-2 翻转链表的非递归实现 | [Java](08x-Linked-List/02-LC-206-Reverse-Linked-List/src/) |
| 8x-3 翻转链表的递归实现 | [Java](08x-Linked-List/03-LC206-Reverse-Linked-List/src/) |
| 8x-4 更多链表问题推荐 | [无代码] |
| | |
| **第九章 归并排序法** | [章节Java源码](09-MergeSort/) |
| 9-1 归并排序法的原理 | [无代码] |
| 9-2 归并过程 | [无代码] |
| 9-3 实现归并过程 | [Java](09-MergeSort/03-Merge/) |
| 9-4 实现归并排序法 | [Java](09-MergeSort/04-MergeSort/) |
| 9-5 归并排序法的微观解读 | [无代码] |
| 9-6 作业：在程序上调试跟踪归并排序法 | [无代码] |
| 9-7 [文字] 作业解析：在程序上调试跟踪归并排序法 | [Java](09-MergeSort/07-MergeSort-Track/src/) |
| 9-8 归并排序法的复杂度分析 | [Java](09-MergeSort/08-MergeSort-Complexity/src/) |
| **第十章 更多关于归并排序法** | [章节Java源码](10-More-about-MergeSort/) |
| 10-1 在有序数组，让归并排序法成为 O(n) 算法 | [Java](10-More-about-MergeSort/01-MergeSort-Basic-Optimization/src/) |
| 10-2 使用插入排序法优化归并排序法 | [Java](10-More-about-MergeSort/02-MergeSort-Optimized-by-InsertionSort/src/) |
| 10-3 归并排序法的内存操作优化 | [Java](10-More-about-MergeSort/03-MergeSort-Advanced-Optimization/src/) |
| 10-4 自底向上的归并排序 | [无代码] |
| 10-5 实现自底向上的归并排序 | [Java](10-More-about-MergeSort/05-MergeSort-Bottom-Up/src/) |
| 10-6 作业：使用插入排序法优化自底向上的归并排序 | [无代码] |
| 10-7 [文字] 作业解析：使用插入排序法优化自底向上的归并排序 | [Java](10-More-about-MergeSort/07-MergeSort-Bottom-Up-Optimized-by-InsertionSort/src/)|
| 10-8 求解数组的逆序对数量 | [Java](10-More-about-MergeSort/08-Reverse-Pairs/src/) |
| 10-9 快速求解数组的逆序对数量 | [Java](10-More-about-MergeSort/09-Solving-Reverse-Pairs-Problem-by-MergeSort/src/) |
| 10-10 归并排序法小结 | [无代码] |
| **第十一章 快速排序法** | [章节Java源码](11-QuickSort/) |
| 11-1 快速排序法的原理 | [无代码] |
| 11-2 Partition | [无代码] |
| 11-3 第一版快速排序法 | [Java](11-QuickSort/03-QuickSort/src/) |
| 11-4 作业：深入理解快速排序的递归过程 | [无代码] |
| 11-5 [文字] 作业解析：使用插入排序法优化快速排序法 | [Java](11-QuickSort/05-QuickSort-Optimized-by-Insertion-Sort/src/) |
| 11-6 第一版快速排序法的问题 | [无代码] |
| 11-7 为快速排序添加随机化 | [Java](11-QuickSort/07-QuickSort-Optimized-by-Random/src/) |
| 11-8 两个作业：深入玩转快速排序 | [无代码] |
| 11-9 [文字] 作业解析：只创建一个 Random 类 | [Java](11-QuickSort/09-QuickSort-Optimized/src/) |
| 11-10 [文字] 作业解析：用算法生成一个特殊的测试用例 | [Java](11-QuickSort/10-Generate-Special-Array/src/) |
| **第十二章 更多关于快速排序法** | [章节Java源码](12-More-about-QuickSort/) |
| 12-1 快速排序算法还有问题 | [无代码](12-More-about-QuickSort/01-Problem-in-All-Same-Array) |
| 12-2 双路快速排序法 | [无代码] |
| 12-3 实现双路快速排序法 | [Java](12-More-about-QuickSort/03-QuickSort-2-Ways/src/) |
| 12-4 快速排序算法的复杂度分析 | [无代码] |
| 12-5 三路快速排序法 | [无代码] |
| 12-6 实现三路快速排序法 | [Java](12-More-about-QuickSort/06-QuickSort-3-Ways/src/) |
| 12-7 作业：一道面试问题，Sort Colors | [无代码] |
| 12-8 [文字] 作业解析：Sort Colors | [Java](12-More-about-QuickSort/08-Sort-Colors/src/) |
| 12-9 作业：Select K 问题 | [无代码] |
| 12-10 [文字解析] 作业解析：Select K 问题 | [Java](12-More-about-QuickSort/10-Select-K/src/) |
| 12-11 快速排序小结 | [无代码] |
| **第十三章 二分查找法** | [章节Java源码](13-Binary-Search/) |
| 13-1 二分查找法 | [无代码] |
| 13-2 二分查找法的递归写法 | [Java](13-Binary-Search/02-Recursive-Binary-Search/src/) |
| 13-3 二分查找法的非递归写法 | [Java](13-Binary-Search/03-Binary-Search/src/) |
| 13-4 作业：Select K 的非递归写法 | [无代码] |
| 13-5 [文字] 作业解析：Select K 的非递归写法 | [Java](13-Binary-Search/05-Select-K-Non-Recursive/src/) |
| 13-6 换个定义实现二分查找法 | [Java](13-Binary-Search/06-Another-Binary-Search/src/) |
| 13-7 作业：换个定义实现算法 | 无代码 |
| 13-8 [文字] 作业解析：换个定义实现 SelectK | [Java](13-Binary-Search/08-Another-Select-K/src/) |
| 13-9 [文字] 作业解析：换个定义实现归并排序法 | [Java](13-Binary-Search/09-Another-MergeSort/src/) |
| **第十四章 更多关于二分查找法** | [章节Java源码](14-More-about-Binary-Search/) |
| 14-1 二分查找法的变种：upper | [无代码] |
| 14-2 实现 upper | [Java](14-More-about-Binary-Search/02-Upper/src/) |
| 14-3 二分查找法的变种：ceil | [Java](14-More-about-Binary-Search/03-Ceil/src/) |
| 14-4 作业：二分查找法的变种：lower_ceil | [无代码] |
| 14-5 [文字] 作业解析：实现 lower_ceil | [Java](14-More-about-Binary-Search/05-Lower-Ceil/src/) |
| 14-6 二分查找法的变种：lower | [无代码] |
| 14-7 实现 lower | [Java](14-More-about-Binary-Search/07-Lower/src/) |
| 14-8 作业：二分查找法的变种：lower_floor 和 upper_floor | [无代码] |
| 14-9 [文字] 作业解析：实现 lower_floor 和 upper_floor | [Java](14-More-about-Binary-Search/09-Lower-Floor-and-Upper-Floor/src/) |
| 14-10 二分查找法总结：二分查找模板  | [无代码] |
| 14-11 [文字]作业解析：换个方式实现二分查找 | [Java](14-More-about-Binary-Search/11-Another-Binary-Search/src/) |
| **第十四章补充 二分查找法应用** | [章节Java源码](14x-Binary-Search/) |
| 14x-1 Leetcode 875 | [无代码] |
| 14x-2 编程实现 Leetcode 875 | [Java](14x-Binary-Search/02-LC875/src/) |
| 14x-3 作业：Leetcode 1011 | [无代码] |
| 14x-4 [文字] 作业解析：编程实现 Leetcode 1011 | [Java](14x-Binary-Search/04-LC1011/src/) |
| 14x-5 更多二分查找相关问题 | [无代码] |
| **第十五章 二分搜索树** | [章节Java源码](15-Binary-Search-Tree/) |
| 15-1 为什么要研究树结构 | [无代码] |
| 15-2 二分搜索树基础 | [Java](15-Binary-Search-Tree/02-Binary-Search-Tree-Basics/src/) |
| 15-3 向二分搜索树中添加元素 | [Java](15-Binary-Search-Tree/03-Add-Elements-in-BST/src/) |
| 15-4 改进添加操作：深入理解递归终止条件 | [Java](15-Binary-Search-Tree/04-Improved-Add-Elements-in-BST/src/) |
| 15-5 作业：和二分搜索树的添加相关的两个问题 | [无代码] |
| 15-6 [文字]作业解析：和二分搜索树的添加相关的两个问题 | [Java](15-Binary-Search-Tree/06-Add-Elements-in-BST-Nonrecursive/src/) |
| 15-7 二分搜索树的查询操作 | [Java](15-Binary-Search-Tree/07-Search-in-BST/src/) |
| 15-8 二分搜索树的前序遍历 | [Java](15-Binary-Search-Tree/08-PreOrder-Traverse-in-BST/src/) |
| 15-9 二分搜索树的中序遍历和后序遍历 | [Java](15-Binary-Search-Tree/09-InOrder-and-PostOrder-Traverse-in-BST/src/) |
| 15-10 深入理解二分搜索树的前中后序遍历 | [无代码] |
| 15-11 二分搜索树前序遍历的非递归实现 | [Java](15-Binary-Search-Tree/11-Non-Recursion-Preorder-Traverse-in-BST/src/) |
| 15-12 二分搜索树的层序遍历 | [Java](15-Binary-Search-Tree/12-Level-Traverse-in-BST/src/) |
| 15-13 删除二分搜索树的最大元素和最小元素 | [Java](15-Binary-Search-Tree/13-Remove-Min-and-Max-in-BST/src/) |
| 15-14 删除二分搜索树的任意元素 | [Java](15-Binary-Search-Tree/14-Remove-Elements-in-BST/src/) |
| 15-15 更多二分搜索树相关话题 | [无代码] |
| **第十六章 集合和映射** | [章节Java源码](16-Set-and-Map/) |
| 16-1 集合基础和基于二分搜索树的集合实现 | [Java](16-Set-and-Map/01-Set-Basics-and-BSTSet/src/) |
| 16-2 基于链表的集合实现 | [Java](16-Set-and-Map/02-LinkedListSet/src/) |
| 16-3 集合类的复杂度分析 | [Java](16-Set-and-Map/03-Time-Complexity-of-Set/src/) |
| 16-4 Leetcode中的集合问题和更多集合相关问题 | [Java](16-Set-and-Map/04-TreeSet-and-Set-Problems-in-Leetcode/src/) |
| 16-5 映射基础 | [Java](16-Set-and-Map/05-Map-Basics/src/) |
| 16-6 基于链表的映射实现 | [Java](16-Set-and-Map/06-LinkedListMap/src/) |
| 16-7 基于二分搜索树的映射实现 | [Java](16-Set-and-Map/07-BSTMap/src/) |
| 16-8 映射的复杂度分析和更多映射相关问题 | [Java](16-Set-and-Map/08-More-about-Map/src/) |
| 16-9 Leetcode上更多集合和映射的问题 | [Java](16-Set-and-Map/09-Leetcode-Problems-about-Map-and-Set/src/) |
| **第十七章 堆** | [章节Java源码](17-Heap/) |
| 17-1 什么是优先队列 | [无代码] |
| 17-2 堆的基础表示 | [Java](17-Heap/02-Heap-Basics/src/) |
| 17-3 向堆中添加元素和Sift Up | [Java](17-Heap/03-Add-and-Sift-Up-in-Heap/src/) |
| 17-4 从堆中取出元素和Sift Down | [Java](17-Heap/04-Extract-and-Sift-Down-in-Heap/src/) |
| 17-5 最直观的堆排序 | [Java](17-Heap/05-Heap-Sort-Basics/src/) |
| 17-6 Heapify 和 Replace | [Java](17-Heap/06-Replace-in-Heap/src/) |
| 17-7 实现 Heapify | [Java](17-Heap/07-Heapify-in-Heap/src/) |
| 17-8 优化的堆排序 | [Java](17-Heap/08-Heap-Sort/src/) |
| 17-9 作业：最小堆 | [无代码] |
| 17-10 [文字] 作业解析：实现最小堆 | [Java](17-Heap/10-Min-Heap/src/) |
| **第十八章 优先队列** | [章节Java源码](18-Priority-Queue/) |
| 18-1 基于堆的优先队列 | [Java](18-Priority-Queue/01-Priority-Queue/src/) |
| 18-2 Top K 问题 | [Java](18-Priority-Queue/02-TopK/src/) |
| 18-3 作业：使用优先队列解决 Select K 问题 | [无代码] |
| 18-4 [文字] 作业解析：使用优先队列解决 Select K 问题 | [Java](18-Priority-Queue/04-LC215/src/) |
| 18-5 使用 Java 中的 PriorityQueue | [Java](18-Priority-Queue/05-Priority-Queue-in-Java/src/) |
| 18-6 使用快排思想和优先队列解决 Top K 问题的比较 | [无代码] |
| 18-7 和堆相关的更多话题和广义队列 | [无代码] |
| **第十九章 冒泡排序法** | [章节Java源码](19-Bubble-Sort/) |
| 19-1 冒泡排序的基本思想 | [无] |
| 19-2 实现冒泡排序法 | [Java](19-Bubble-Sort/02-Bubble-Sort/src/) |
| 19-3 冒泡排序的优化 | [Java](19-Bubble-Sort/03-Bubble-Sort-Optimized/src/) |
| 19-4 冒泡排序还能优化 | [Java](19-Bubble-Sort/04-Bubble-Sort-Optimized2/src/) |
| 19-5 作业：换个方式实现冒泡排序 | [无代码] |
| 19-6 作业解析：换个方式实现冒泡排序 | [Java](19-Bubble-Sort/06-Another-Bubble-Sort/src) |
| 19-7 冒泡排序的特点 | [无代码] |
| **第二十章 希尔排序法** | [章节Java源码](20-Shell-Sort/) |
| 20-1 插入排序法和冒泡排序法的启迪 | [无代码] |
| 20-2 希尔排序法的基本原理 | [无代码] |
| 20-3 实现希尔排序法 | [Java](20-Shell-Sort/03-Shell-Sort/src/) |
| 20-4 希尔排序法的性能 | [Java](20-Shell-Sort/04-Shell-Sort-Performance/src/) |
| 20-5 换个方式实现希尔排序法 | [Java](20-Shell-Sort/05-Another-Shell-Sort/src/) |
| 20-6 步长序列 | [Java](20-Shell-Sort/06-H-Sequence/src/) |
| 20-7 希尔排序和超参数 | [无代码] |
| **第二十一章 基于比较排序算法大总结** | [无代码] |
| 21-1 基于比较排序算法大总结 | [无代码] |
| 21-2 什么是排序算法的稳定性 | [无代码] |
| 21-3 基础排序算法的稳定性 | [无代码] |
| 21-4 高级排序算法的稳定性 | [无代码] |
| **第二十二章 线段树** | [章节Java源码](22-Segment-Tree/) |
| 22-1 什么是线段树 | [无代码] |
| 22-2 线段树基础表示 | [Java](22-Segment-Tree/02-Segment-Tree-Basics/src/) |
| 22-3 创建线段树 | [Java](22-Segment-Tree/03-Building-Segment-Tree/src/) |
| 22-4 线段树中的区间查询 | [Java](22-Segment-Tree/04-Query-in-Segment-Tree/src/) |
| 22-5 Leetcode上线段树相关的问题 | [Java](22-Segment-Tree/05-Segment-Tree-Problems-in-Leetcode/src/) |
| 22-6 线段树中的更新操作 | [Java](22-Segment-Tree/06-Update-Single-Element-in-Segment-Tree/src/) |
| 22-7 更多线段树相关的话题 | [无代码] |
| **第二十三章 Trie** | [章节Java源码](23-Trie/) |
| 23-1 什么是Trie字典树 | [无代码] |
| 23-2 Trie字典树基础 | [Java](23-Trie/02-Trie-Basics/src/) |
| 23-3 Trie字典树的查询 | [Java](23-Trie/03-Searching-in-Trie/src/) | 
| 23-4 Trie字典树的前缀查询 | [Java](23-Trie/04-Prefix-in-Trie/src/) |
| 23-5 Trie字典树和简单的模式匹配 | [Java](23-Trie/05-Trie-and-Pattern-Match/src/) |
| 23-6 Trie字典树和字符串映射 | [Java](23-Trie/06-Trie-and-Map/src/) |
| 23-7 更多和Trie字典树相关的话题 | [无代码] |
| 23-8 [文字补充] 基于哈希表或者数组的Trie | [Java](10-Trie/08-Trie-Using-HashMap-and-Array/src/) |
| **第二十四章 并查集** | [章节Java源码](24-Union-Find/) |
| 24-1 什么是并查集 | [Java](24-Union-Find/01-What-is-UnionFind/src/) |
| 24-2 Quick Find | [Java](24-Union-Find/02-Quick-Find/src/) |
| 24-3 Quick Union | [Java](24-Union-Find/03-Quick-Union/src/) |
| 24-4 基于size的优化 | [Java](24-Union-Find/04-Optimized-by-Size/src/) |
| 24-5 基于rank的优化 | [Java](24-Union-Find/05-Optimized-by-Rank/src/) |
| 24-6 路径压缩 | [Java](24-Union-Find/06-Path-Compression/src/) |
| 24-7 更多和并查集相关的话题 | [Java](24-Union-Find/07-More-about-Union-Find/src/) |
| | |

课程更新中，敬请期待：）

---

**大家加油！：）**